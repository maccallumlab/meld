#
# Copyright 2015 by Justin MacCallum, Alberto Perez, Ken Dill
# All rights reserved
#

"""
Methods to read template coordinates from a system object and build elastic network restraints prior to simulation for a specific chain.
"""

import numpy as np  # type: ignore
from scipy.spatial.distance import pdist  # type: ignore
from scipy.spatial.distance import squareform  # type: ignore
from typing import List, Optional, Union

from meld.system import restraints
from meld.system import meld_system
from meld.system import scalers
from meld import unit as u
from meld.util import strip_unit

def create_elastic_network_restraints(
    system: meld_system.System,
    chain_indices: Union[int, List],
    cutoff: u.Quantity = 1.0 * u.nanometer,
    restrained_atom: str = 'CA',
    residue_separation: int = 3,
    k: u.Quantity = 2500 * u.kilojoule_per_mole / u.nanometer ** 2,
    only_inter: bool = False,
    scaler: Optional[scalers.RestraintScaler] = None,
    write_file: Optional[str] = None,
):
    """
    Create elastic network restraints between specified backbone atoms within a single chain

    Args:
    system: system object that is used for indexing

    chain_indices: provide a single int or list of integer ids that you want restraints built between
        if you only want intra chain restraints (i.e. only restraints within a chain) only specify a single index
        and just re-use the function for as many chains as you want intra chain restraints.
        if you want restraints between chains (e.g. restraints to keep a complex together), provide a list of indices
    cutoff: distance cutoff. Any restrained_atoms below the cutoff will have elastic network restraints created between them
    restrained_atom: atom name that restraints between residues will use. Currently only a single atom name is supported
    residue_separation: minimum sequence separation between restraints. 
    k: force constant
    only_inter: only build restraints between chains. do not build restraints within a chain. useful if elastic network restraints
                have come from somewhere else (e.g. martinize for martini builder)
    scaler: Optional specify a Scaler to vary the force constant with alpha. 
            If ``None``, then a constant 1.0 scaler will be used.
    write_file: Optional parameter to output restraints to a text file. 
                Useful for comparing restraints generated by different functions
    only_intra
    """
    # Ensure that k and cutoff are specified in the correct units
    k_val = strip_unit(k, u.kilojoule_per_mole / u.nanometer ** 2)
    cutoff_val = strip_unit(cutoff, u.nanometer)

    # Check to see if scaler is specified
    scaler = scalers.ConstantScaler() if scaler is None else scaler

    # If chain indices are a single integer convert to iterable
    if isinstance(chain_indices, int):
        chain_indices = [chain_indices]
    
    # Get all residues from every chain to build restraints
    chains = list(system.topology.chains())
    restrained_chains = [chains[chain_index] for chain_index in chain_indices]
    residues = []
    
    for restrained_chain in restrained_chains:
        for residue in restrained_chain.residues():
            # If explicitly solvated we need to ignore non protein residues.
            if residue.name not in ['HOH', 'WAT', 'W', 'Na+', 'Ca2+', 'K+', 'Cl-']:
                residues.append(residue)
    
    # Extract atom indices for CA atoms
    ca_indices = []
    for residue in residues:
        # Not using chainid because that converts to relative numbering where as openmm uses absolute numbering within chains
        ca_index = system.index.atom(residue.index, restrained_atom, expected_resname=residue.name,)
        ca_indices.append(ca_index)
        
    # Get initial coordinates from the system
    coordinates = system.template_coordinates
    ca_coordinates = coordinates[ca_indices]
    
    # Calculate pairwise distances
    dists = pdist(ca_coordinates)
    
    # Transform dists into a nres by nres distance matrix
    dist_map = squareform(dists)
    
    # Grab upper (or lower doesn't matter chose upper arbitrarily) diagonal because dist_map is symmetric
    dist_map = np.triu(dist_map) 
    
    # Make sure the length of the dist_map is the same as the length of residues
    # This will not be the case if restrained_atom isn't present in every residue
    # In that case, this function won't work
    if dist_map.shape[0] != len(residues):
        raise ValueError("Mismatch between distance matrix and number of residues. Usually this means that restrained_atom is not present in every residue of the chain.")
    
    # Triu sets off diagonal elements to zero so we look for things above zero and below our cutoff
    close_pairs = np.argwhere((dist_map > 0) & (dist_map < cutoff_val))
    
    # Collect the precise distance of each close pair
    close_distances = []
    for pair in close_pairs:
        close_distance = dist_map[pair[0]][pair[1]]
        close_distances.append(close_distance)
    
    # Create restraints
    rests = []
    for pair, dist in zip(close_pairs, close_distances):
        i, j = pair[0], pair[1]
        
        # Skip writing restraints if only_inter turned on and chain indexes are the same.
        if only_inter and residues[i].chain.index == residues[j].chain.index:
            continue
            
        # Only create restraints if residues are separated by at least residue_separation
        if abs(i - j) >= residue_separation:
            rest = system.restraints.create_restraint(
                "distance",
                scaler=scaler,
                atom1 = system.index.atom(residues[i].index, restrained_atom, expected_resname=residues[i].name,), 
                atom2 = system.index.atom(residues[j].index, restrained_atom, expected_resname=residues[j].name,),
                r1 = 0.0 * u.nanometer,
                r2 = 0.0 * u.nanometer,
                r3 = dist * u.nanometer,
                r4 = (dist + 0.2) * u.nanometer,
                k = k_val * u.kilojoule_per_mole / u.nanometer ** 2,
                )
            rests.append(rest)
            
    # If write_file is set - write the restraints to a separate file.
    # Mostly a sanity check to compare to previous ways to generate restraints
    if write_file:
        with open(write_file, 'w') as f:
            for pair, dist in zip(close_pairs, close_distances):
                i, j = pair[0], pair[1]

                # Skip writing restraints if only_inter turned on and chain indexes are the same.
                if only_inter and residues[i].chain.index == residues[j].chain.index:
                    continue

                if abs(i - j) >= residue_separation:
                    f.write(f"{residues[i].chain.index} {residues[i].index} {restrained_atom} {residues[i].name} {residues[j].chain.index} {residues[j].index} {restrained_atom} {residues[j].name} {dist} {k_val} \n")
            
                
    return rests

def add_elastic_network_restraints(
    system: meld_system.System,
    rests: List[restraints.SelectableRestraint],
    active_fraction: float = 1.0,
    max_grp_len: int = 64,
):
    """
    For performance reasons, we add restraints in groups of grp_len

    Args:
    system: system object that restraint belongs to
    rests: list of SelectableRestraint restraints
    active fraction: fraction of restraints that must remain activated
    max_grp_len: length of each restraint group.
    """
    collection: List[Union[restraints.RestraintGroup, restraints.SelectableRestraint]]  = []
    grp : List[restraints.SelectableRestraint] = []
    for rest in rests:
        # Check to see if the length of the group is equal to the max group length
        if len(grp) == max_grp_len:
            # If so add group to collection and empty group
            g = system.restraints.create_restraint_group(grp, len(grp)) 
            collection.append(g)
            grp = []
        
        # Append restraints to group until max_grp_len is reached
        grp.append(rest)
    
    
    # When out of the for loop there will be remaining restraints that have a total length less than max_grp_len
    # So we add the remaining restraints to the collection
    g = system.restraints.create_restraint_group(grp, len(grp)) 
    collection.append(g)
    
    # Add restraints to system
    system.restraints.add_selectively_active_collection(collection, int(len(collection) * active_fraction))